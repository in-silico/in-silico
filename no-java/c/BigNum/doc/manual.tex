\documentclass{book}

\usepackage{verbatim}
\usepackage{mathtools}
\usepackage{amsmath}


\begin{document}

\chapter{Using BigNum library}
\label{chap:api}
The following is the structure of an arbitrary precision integer in the BigNum library.
\begin{verbatim}
/**
 * Structure that represents big integers, d[0] is the least significant
 * digit while d[size-1] is the most significant digit
 */
typedef struct {
    bn_word maxSize; /*Maximum number of digits that d can hold*/
    bn_word size; /*number of digits*/
    char sign; /*zero->negative, other->positive*/
    bn_word *d; /*value of each digits*/
} BigInt;
\end{verbatim}

This structure represents a common positional number system, so the Big Integer N is determined by the following expression:

\[N = \sum_{i=0}^{size-1}{d_i b^i} \quad\quad (0 \le d_i < b) \]

where $b$ represents the number system base, $d_i$  are the digits which represent the number N and $size$ is the amount of digits that represent N in base $b$.

In BigNum library the base $b$ is $2^B$, where $B$ is the bit length of an \verb+int+ data type in the enviroment used for running the library, normally this number is 16 for microcontrollers and 32 for general purpose CPU's and high level embedded systems.\\

Notice that the sign representation used in "BigNum" is the sign-magnitude representation, for this reason the big integer structure has a "sign" field.

It is important to mention that the $maxSize$ field establish a bound about the biggest and smallest number which can be represented, for example if a big integer $T$ has a $maxSize$ value of 50, this big integer can hold a number $k$ such that $-2^{50B}<k<2^{50B}$, pay attention to this for avoiding overflow errors in BigNum library.

\section{BigInteger fundamentals}

\subsection{How to create an arbitrary precision number in BigNum Library?}

For creating a new big integer with this library, you can use the following function:

\begin{verbatim}
BigInt* bnNewBigInt(unsigned int maxSize, unsigned int initVal);
\end{verbatim}

\paragraph{Purpuse}:\\

To create a Big Integer with dynamic memory allocation.

\paragraph{Arguments}:\\

\begin{itemize}
\item {\bf maxSize:} Is the biggest amount of base $2^B$ digits (where B is the bit length of an \verb+int+ data type)  that this big integer can handle, remember that this number represents a constraint about the biggest and smallest number that can be represented in the big integer,therefore it must be choosen with care because you can not change it after the big integer creation.\\
\item {\bf initVal:} Is the initial value of the new big integer, this number must satisfy the following: $0 \leq initval< 2^B$ , the reason of this is because the data type of this argument is an \verb+unsigned int+, for initializing the big integer with numbers bigger than $2^B$ or with negative numbers review the function \verb+bnStrToInt+.
\end{itemize}

\paragraph{Return Value}:\\

Returns a pointer to the new big integer created by this function.

\paragraph{Example}:\\

\begin{verbatim}
    BigInt *a=bnNewBigInt(50, 0);
\end{verbatim}

this example builds a big integer with 50 base $b$ digits with an initial value of 0.

\subsection{How to initialize an arbitrary precision number in BigNum Library?}

In the latter subsection was explained a 

\subsection{How to initialize an arbitrary precision number in BigNum?}

In the last section it was told that the big integer creation function has a constrained mechanism for initializing the big integer, in general it is possible to use the following function for this purpose.\\

\verb+void bnStrToInt(BigInt *ans, const char *input)+\\

\paragraph{Purpose:} 

To get a \emph{big integer} representation of a number represented as a characters array.

\paragraph{Arguments:}

\begin{itemize}
\item

\br{ans:} it is a pointer to the \verb+BigInt+ struct which will save the number represented by the characters array \verb+input+, the big integer pointed by \verb+ans+ must have enough size in digits, if this is not the case the conversion can not be achieved.

\item 

\br{input:} it is a pointer to a characters array, this array represents a number in the common way (e.g. "-1234"), it is is important that the end of the number is represented by the \emph{end of line} character ('\0').  

\end{itemize}

\paragraph{Return Value:}

None.

\paragraph{Examples:}

\begin{itemize}
\item

\begin{verbatim}
	BigInt *a=bnNewBigInt(50, 0);
	bnStrToInt(a, “-123456789000”);
\end{verbatim}

\item

\begin{verbatim}
	BigInt *a=bnNewBigInt(50, 0);
	char *input=”-123456789000”;
	bnStrToInt(a, input);
\end{verbatim}
\end{itemize}

In both cases the big integer \verb+a+ will represent the number -123456789000.

\subsection{How to get a conventional and readable representation of a BigNum arbitrary precision number?}

It is useful to get an appropiate representation of a big integer for the human beings after all the operations required have been applied to the number, taking into account that the \emph{BigNum} number representation is not very natural because of some aspects as the numerical base, the following function gives a mechanism for getting a decimal reprensentation of a big integer.\\

\verb+void bnIntToStr(char* ans, BigInt* x)+\\

\paragraph{Arguments:}

\begin{itemize}
\item

\br{ans:}

\item 

\br{x:}  

\end{itemize}

\paragraph{Return Value:}

None.

\paragraph{Examples:}

\begin{itemize}
\item

\begin{verbatim}
	char ans[100];
	BigInt *a=bnNewBigInt(50, 0);
	char *input=”-123456789000”;
	bnStrToInt(a, input);
	bnIntToStr(ans,a);
\end{verbatim}
\end{itemize}


\chapter{Intern Structure}

\section{Addition and subtraction}
For addition and subtraction the library uses the schoolbook algorithms. To support signed integer addition and subtraction, the library has methods implemented for unsigned addition and subtraction. The function for unsigned addition is:
    \begin{verbatim}
    bnUAddInt(BigInt *res, BigInt *a, BigInt *b)
    \end{verbatim}
The function receives two integers \verb+a+ and \verb+b+ and adds them ignoring the signs in \verb+res+. Let $a_i$ and $b_i$ be the digit $i$-th of the first and second operands respectively, and $c_i$ be the $i$-th digit of the result, then the internal behavior of this function is given by:
\[c_i = a_i + b_i + k \]
where $k$ is the carry digit of the operation on the $(i-1)$-th digit. The function for unsigned subtraction is:
    \begin{verbatim}
    bnUSubInt(BigInt *res, BigInt *a, BigInt *b)
    \end{verbatim}
The function receives two integers \verb+a+ and \verb+b+ and subtracts them in \verb+res+ as with natural numbers, the magnitude of \verb+a+ must be greater or equal to \verb+b+ to avoid a less than zero result. Let $a_i$ and $b_i$ be the digit $i$-th of the first and second operands respectively, and $c_i$ be the $i$-th digit of the result, then the internal behavior of this function is given by:
\[c_i = a_i - b_i - k \]
where $k$ is the borrow digit of the operation on the $(i-1)$-th digit. \\

With the operations for addition and subtraction on natural numbers implemented, is easy to implement a signed addition with the following algorithm:
\begin{itemize}
\item If the signs of both operands are equal, then use unsigned addition and put the sign of the operands to the results
\item If the signs are different, then use unsigned subtraction to subtract the operand of lowest magnitude from the operand of highest magnitude and keep the sign of the operand of highest magnitude.
\end{itemize}

With the signed addition implemented, the signed subtraction was implemented by changing the sign of the second operand and calling the signed addition. The signature of the functions for signed addition and subtraction was explained in the chapter \ref{chap:api}.

\section{Multiplication}

\section{Division}
 

\end{document}
