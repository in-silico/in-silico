\documentclass{book}

\usepackage{verbatim}
\usepackage{mathtools}
\usepackage{amsmath}


\begin{document}

\chapter{Using BigNum library}
\label{chap:api}
The following is the structure of an arbitrary precision integer in the BigNum library.
\begin{verbatim}
/**
 * Structure that represents big integers, d[0] is the least significant
 * digit while d[size-1] is the most significant digit
 */
typedef struct {
    bn_word maxSize; /*Maximum number of digits that d can hold*/
    bn_word size; /*number of digits*/
    char sign; /*zero->negative, other->positive*/
    bn_word *d; /*value of each digits*/
} BigInt;
\end{verbatim}

This structure represents a common positional number system, so the Big Integer N is determined by the following expression:

\[N = \sum_{i=0}^{size-1}{d_i b^i} \quad\quad (0 \le d_i < b) \]

where $b$ represents the number system base, $d_i$  are the digits which represent the number N and $size$ is the amount of digits that represent N in base $b$.

In BigNum library the base $b$ is $2^B$, where $B$ is the bit length of an \verb+int+ data type in the enviroment used for running the library, normally this number is 16 for microcontrollers and 32 for general purpose CPU's and high level embedded systems.\\

Notice that the sign representation used in "BigNum" is the sign-magnitude representation, for this reason the big integer structure has a "sign" field.

It is important to mention that the $maxSize$ field establish a bound about the biggest and smallest number which can be represented, for example if a big integer $T$ has a $maxSize$ value of 50, this big integer can hold a number $k$ such that $-2^{50B}<k<2^{50B}$, pay attention to this for avoiding overflow errors in BigNum library.

\section{BigInteger fundamentals}

\subsection{How to create an arbitrary precision number in BigNum Library?}

For creating a new big integer with this library, you can use the following function:

\begin{verbatim}
BigInt* bnNewBigInt(unsigned int maxSize, unsigned int initVal);
\end{verbatim}

\paragraph{Purpuse}:\\

To create a Big Integer with dynamic memory allocation.

\paragraph{Arguments}:\\

\begin{itemize}
\item {\bf maxSize:} Is the biggest amount of base $2^B$ digits (where B is the bit length of an \verb+int+ data type)  that this big integer can handle, remember that this number represents a constraint about the biggest and smallest number that can be represented in the big integer,therefore it must be choosen with care because you can not change it after the big integer creation.\\
\item {\bf initVal:} Is the initial value of the new big integer, this number must satisfy the following: $0 \leq initval< 2^B$ , the reason of this is because the data type of this argument is an \verb+unsigned int+, for initializing the big integer with numbers bigger than $2^B$ or with negative numbers review the function \verb+bnStrToInt+.
\end{itemize}

\paragraph{Return Value}:\\

Returns a pointer to the new big integer created by this function.

\paragraph{Example}:\\

\begin{verbatim}
    BigInt *a=bnNewBigInt(50, 0);
\end{verbatim}

this example builds a big integer with 50 base $b$ digits with an initial value of 0.

\subsection{How to initialize an arbitrary precision number in BigNum Library?}

In the last section it was told that the big integer creation function has a constrained mechanism for initializing the big integer, in general it is possible to use the following function for this purpose.\\

\verb+void bnStrToInt(BigInt *ans, const char *input)+\\

\paragraph{Purpose:} 

To get a \emph{big integer} representation of a number represented as a characters array.

\paragraph{Arguments:}

\begin{itemize}
\item {\bf ans:} it is a pointer to the \verb+BigInt+ struct which will save the number represented by the characters array \verb+input+, the big integer pointed by \verb+ans+ must have enough size in digits, if this is not the case the conversion can not be achieved.

\item {\bf input:} it is a pointer to a characters array, this array represents a number in the common way (e.g. "-1234"), it is is important that the end of the number is represented by the \emph{end of line} character (\verb+'\0'+).  

\end{itemize}

\paragraph{Return Value}:\\

None.

\paragraph{Examples:}

\begin{itemize}
\item

\begin{verbatim}
	BigInt *a=bnNewBigInt(50, 0);
	bnStrToInt(a, “-123456789000”);
\end{verbatim}

\item

\begin{verbatim}
	BigInt *a=bnNewBigInt(50, 0);
	char *input=”-123456789000”;
	bnStrToInt(a, input);
\end{verbatim}
\end{itemize}

In both cases the big integer \verb+'a'+ will represent the number \verb+"-123456789000"+.

\subsection{How to get a conventional and readable representation of a BigNum arbitrary precision number?}

It is useful to get an appropiate representation of a big integer for the human beings after all the operations required have been applied to the number, taking into account that the \emph{BigNum} number representation is not very natural because of some aspects as the numerical base, the following function gives a mechanism for getting a decimal reprensentation of a big integer.\\

\verb+void bnIntToStr(char* ans, BigInt* x)+\\

\paragraph{Purpose:} 

To get a decimal representation saved in a characteres array from a big integer.

\paragraph{Arguments:}

\begin{itemize}
\item{\bf ans:}

Pointer to the characters array where the decimal representation of the big integer \verb+'x'+ will be saved, keep in mind that the array size must be enough for saving the decimal representation of \verb+'x'+. This  function appends an \emph{end of line} character to the array pointed by ans.

\item {\bf x:}

Pointer to the big integer whose decimal representation is desired.

\end{itemize}

\paragraph{Return Value}:\\

None.

\paragraph{Examples:}

\begin{itemize}
\item

\begin{verbatim}
	char ans[100];
	BigInt *a=bnNewBigInt(50, 0);
	char *input=”-123456789000”;
	bnStrToInt(a, input);
	bnIntToStr(ans,a);
\end{verbatim}
\end{itemize}

After executing this code the value of the array pointed by \verb+ans+ will be \verb+"-123456789000"+.

\subsection{How to free the memory assigned to a big integer?}

It is very important to remember that you must free the allocated memory for a big integer when it is not needed anymore, because the memory allocation is dynamic, therefore you must explicitly free that memory space for using it in the future.\\

\verb+void bnIntToStr(char* ans, BigInt* x)+\\

\paragraph{Purpose:} 

To get a decimal representation saved in a characteres array from a big integer.

\paragraph{Arguments:}

\begin{itemize}
\item{\bf ans:}

Pointer to the characters array where the decimal representation of the big integer \verb+'x'+ will be saved, keep in mind that the array size must be enough for saving the decimal representation of \verb+'x'+. This  function appends an \emph{end of line} character to the array pointed by ans.

\item {\bf x:}

Pointer to the big integer whose decimal representation is desired.

\end{itemize}

\paragraph{Return Value}:\\

None.

\paragraph{Examples:}

\begin{itemize}
\item

\begin{verbatim}
	char ans[100];
	BigInt *a=bnNewBigInt(50, 0);
	char *input=”-123456789000”;
	bnStrToInt(a, input);
	bnIntToStr(ans,a);
\end{verbatim}
\end{itemize}

After executing this code the value of the array pointed by \verb+ans+ will be \verb+"-123456789000"+.


\chapter{Intern Structure}

\section{Addition and subtraction}
\label{sect:add}
For addition and subtraction the library uses the schoolbook algorithms but in base $b$. To support signed integer addition and subtraction, the library has methods implemented for unsigned addition and subtraction. The function for unsigned addition is:
    \begin{verbatim}
    bnUAddInt(BigInt *res, BigInt *a, BigInt *b)
    \end{verbatim}
The function receives two integers \verb+a+ and \verb+b+ and adds them ignoring the signs in \verb+res+. Let $a_i$ and $b_i$ be the digit $i$-th of the first and second operands respectively, and $c_i$ be the $i$-th digit of the result, then the internal behavior of this function is given by:
\[c_i = a_i + b_i + k \]
where $k$ is the carry digit of the operation on the $(i-1)$-th digit. The function for unsigned subtraction is:
    \begin{verbatim}
    bnUSubInt(BigInt *res, BigInt *a, BigInt *b)
    \end{verbatim}
The function receives two integers \verb+a+ and \verb+b+ and subtracts them in \verb+res+ as with natural numbers, the magnitude of \verb+a+ must be greater or equal to \verb+b+ to avoid a less than zero result. Let $a_i$ and $b_i$ be the digit $i$-th of the first and second operands respectively, and $c_i$ be the $i$-th digit of the result, then the internal behavior of this function is given by:
\[c_i = a_i - b_i - k \]
where $k$ is the borrow digit of the operation on the $(i-1)$-th digit. \\

With the operations for addition and subtraction on natural numbers implemented, is easy to implement a signed addition with the following algorithm:
\begin{itemize}
\item If the signs of both operands are equal, then use unsigned addition and put the sign of the operands to the results
\item If the signs are different, then use unsigned subtraction to subtract the operand of lowest magnitude from the operand of highest magnitude and keep the sign of the operand of highest magnitude.
\end{itemize}

With the signed addition implemented, the signed subtraction was implemented by changing the sign of the second operand and calling the signed addition. The signature of the functions for signed addition and subtraction was explained in the chapter \ref{chap:api}.

\subsection{Complexity}
Let $n$ be the number of digits in base $2^B$ of each operand. As both addition and subtraction make a single loop on the number of digits its complexity is $O(n)$.

\section{Multiplication}
For multiplication the library also uses the schoolbook algorithm over base $2^B$. When someone wants to multiply numbers of several digits in base 10, the only thing that person needs to know is how to multiply single digits (Using the multiplication table for example) and also how to add numbers of several digits. For this algorithm we use the fact that the processor already knows how to multiply two numbers of a single digit in base $2^B$ and the algorithm of section \ref{sect:add} to add numbers of several digits in base $2^B$. The algorithm to multiply two big integers $a$ and $b$ require two temporal big integer numbers (\verb+tmp+ and \verb+sum+) to store the result of multiplying all $a$ by the digit $i$ of $b$ and the sum of all partial multiplication respectively, the algorithm works as follows:

\begin{itemize}
\item set \verb+sum+ to zero
\item for each digit $b_i$ of $b$:
    \begin{itemize}
    \item multiply the operand $a$ by the digit $b_i$ and store it in \verb+tmp+
    \item accumulate \verb+tmp+ shifted $i$ digits to the left in \verb+sum+ (\verb/sum = sum + digitShift(tmp,i)/)
    \end{itemize}
\end{itemize}

The previous algorithm uses a method for multiplying a full big integer by a single digit in base $2^B$, the method \verb+bnMulIntWord(BigInt* res, BigInt *a, bn_word b)+ were implemented for that purpose. The implementation for this method also uses the schoolbook algorithm, taking into account that the multiplication of two single digits never overflows a two digit variable the algorithm multiplies each digit of $a$ by the digit $b$ and stores the result in a variable $m$ of type \verb+bn_dword+ and $2B$ bits capacity. Then the least significant digit in base $2^B$ of $m$ is stored in the resulting integer and the other digit of $m$ is taken as the carry for the next operation.

\subsection{Complexity}
Let $n$ be the number of digits in base $2^B$ of the operands $a$ and $b$. The complexity of \verb+bnMulIntWord+ would be $O(n)$, and the complexity of \verb+bnMulInt+ would be $O(n^2)$.

\section{Division}
 
\section{Exponentiation and modular exponentiation}

\end{document}
