\documentclass[a4paper, 11pt, oneside]{report}

% idioma
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

%tablas
\usepackage{booktabs}

%rotar tablas
\usepackage{rotating}

%color tablas
\usepackage{colortbl}

%espaciado
\usepackage{setspace}
\onehalfspacing
\setlength{\parindent}{0pt}
\setlength{\parskip}{2.0ex plus0.5ex minus0.2ex}

% inserción url's notas de pie.
\usepackage{url}

%gráficos
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{array}

%otros
\usepackage{verbatim} 

% Paquetes de la AMS:
\usepackage{amsmath, amsthm, amsfonts}
\addto\captionsspanish{\def\refname{\textsc{Bibliografía}}}

\begin{document}


\chapter{DP}

\section{LIS}

Longest Increasing Subsequence


The Longest Increasing Subsequence problem is to find the longest increasing subsequence of a given sequence. It also reduces to a Graph Theory problem of finding the longest path in a Directed acyclic graph.

Formally, the problem is as follows:

Given a sequence $a_{1}, a_{2}, ..., a_{n}$, find the largest subset such that for every $i < j, a_{i} < a_{j}$.

\subsection*{Techniques}

\subsubsection{Longest Common Subsequence}

A simple way of finding the longest increasing subsequence is to use the Longest Common Subsequence (Dynamic Programming) algorithm.

\begin{itemize}

	\item Make a sorted copy of the sequence A, denoted as B. $O(nlog(n))$ time.
	
	\item Use Longest Common Subsequence on with A and B. $O(n^2)$ time.

\end{itemize}

\subsubsection*{Dynamic Programming}

There is a straight-forward Dynamic Programming solution in $O(n^2)$ time. Though this is asymptotically equivalent to the Longest Common Subsequence version of the solution, the constant is lower, as there is less overhead.

Let A be our sequence $a_{1}, a_{2}, ..., a_{n}$. Define $q_{k}$ as the length of the longest increasing subsequence of A, subject to the constraint that the subsequence must end on the element $a_{k}$. The longest increasing subsequence of A must end on some element of A, so that we can find its length by searching for the maximum value of q. All that remains is to find out the values qk.

But $q_{k}$ can be found recursively, as follows: consider the set $S_{k}$ of all $i < k$ such that $a_{i} < a_{k}$. If this set is null, then all of the elements that come before $a_{k}$ are greater than it, which forces $q_{k} = 1$. Otherwise, if $S_{k}$ is not null, then q has some distribution over Sk. By the general contract of q, if we maximize q over $S_{k}$, we get the length of the longest increasing subsequence in $S_{k}$; we can append $a_{k}$ to this sequence, to get that:

$q_{k} = max(q_{j}|j \epsilon S_{k}) + 1$

If the actual subsequence is desired, it can be found in $O(n)$ further steps by moving backward through the q-array, or else by implementing the q-array as a set of stacks, so that the above "+ 1" is accomplished by "pushing" ak into a copy of the maximum-length stack seen so far.

Some pseudo-code for finding the length of the longest increasing subsequence:

\begin{verbatim}
function lis_length( a )
    n := a.length
    q := new Array(n)
    for k from 0 to n:
        max := 0;
        for j from 0 to k, if a[k] > a[j]:
            if q[j] > max, then set max = q[j].
        q[k] := max + 1;
    max := 0
    for i from 0 to n:
        if q[i] > max, then set max = q[i].
    return max;
\end{verbatim}

\subsection*{Faster Algorithm}

There's also an O(nlogn) solution based on some observations. Let $A_{i,j}$ be the smallest possible tail out of all increasing subsequences of length j using elements.

Observe that, for any particular i, $A_{i,1} < A_{1,2} < ... < A_{i,j}$. This suggests that if we want the longest subsequence that ends with $a_{i + 1}$, we only need to look for a j such that $A_{i,j} < A_{i} + 1 <= A_{i,j} + 1$ and the length will be j + 1.

Notice that in this case, $A_{i + 1,j + 1}$ will be equal to $a_{i + 1}$, and all $A_{i + 1,k}$ will be equal to $A_{i,k}$ for $k \neq j + 1$.

Furthermore, there is at most one difference between the set $A_i$ and the set $A_{i + 1}$, which is caused by this search.

Since A is always ordered in increasing order, and the operation does not change this ordering, we can do a binary search for every single $a_{1}, a_{2}, ..., a_{n}$.

\begin{verbatim}

#include <vector>
#include <iostream>
using namespace std;


/* Algoritmo N^2
	int lis(int *entrada, int numero)
	{
		int valores[numero];
		for(int i = 0; i < numero; i++)
		    valores[i] = 0;
		int mejorM = 0;
		for(int i = 0; i < numero; i++)
		{
		    int mejor = 0;
		    for(int j = 0; j < i; j++)
		    {
		        if(entrada[j] <= entrada[i])
		            mejor = max(mejor, valores[j]);
		    }
		    valores[i] = mejor + 1;
		    mejorM = max(mejorM, valores[i]);
		}
		return mejorM;
	}
*/

/* Finds longest strictly increasing subsequence. O(n log k) algorithm. */
void find_lis(vector<int> &a, vector<int> &b)
{
	vector<int> p(a.size());
	int u, v;

	if (a.empty()) return;

	b.push_back(0);

	for (size_t i = 1; i < a.size(); i++) {
		if (a[b.back()] < a[i]) {
			p[i] = b.back();
			b.push_back(i);
			continue;
		}

		for (u = 0, v = b.size()-1; u < v;) {
			int c = (u + v) / 2;
			if (a[b[c]] < a[i]) u=c+1; else v=c;
		}

		if (a[i] < a[b[u]]) {
			if (u > 0) p[i] = b[u-1];
			b[u] = i;
		}
	}

	for (u = b.size(), v = b.back(); u--; v = p[v]) b[u] = v;
}

vector<int> lista;
vector<int> lis;

int main()
{
	int t;
	cin >> t;
	for(int i = 0; i < t; i++)
	{
            lista.clear();
            lis.clear();
            int p;
            cin >> p;
            for(int j = 0; j < p; j++)
            {
                int n;
                cin >> n;
                lista.push_back(n);
            }
            find_lis(lista, lis);
            cout << lis.size() << endl;
	}

	return 0;
}

\end{verbatim}

\chapter{Estructuras}

\section{Fenwick tree}

Fenwick tree (aka Binary indexed tree) is a data structure that maintains a sequence of elements, and is able to compute cumulative sum of any range of consecutive elements in O(logn) time. Changing value of any single element needs O(logn) time as well.

The structure is space-efficient in the sense that it needs the same amount of storage as just a simple array of n elements.

\begin{verbatim}

// In this implementation, the tree is represented by a vector<int>.
// Elements are numbered by 0, 1, ..., n-1.
// tree[i] is sum of elements with indexes i&(i+1)..i, inclusive.
// (Note: this is a bit different from what is proposed in Fenwick's article.
// To see why it makes sense, think about the trailing 1's in binary
// representation of indexes.)

// Creates a zero-initialized Fenwick tree for n elements.
vector<int> create(int n) { return vector<int>(n, 0); }

// Returns sum of elements with indexes a..b, inclusive
int query(const vector<int> &tree, int a, int b) {
    if (a == 0) {
        int sum = 0;
        for (; b >= 0; b = (b & (b + 1)) - 1)
          sum += tree[b];
        return sum;
    } else {
        return query(tree, 0, b) - query(tree, 0, a-1);
    }
}

// Increases value of k-th element by inc.
void increase(vector<int> &tree, int k, int inc) {
    for (; k < (int)tree.size(); k |= k + 1)
        tree[k] += inc;
}

\end{verbatim}

\chapter{Geometria}

\section{Circle circle}

\begin{verbatim}

#include <map>
#include <utility>
#include <iostream>
#include <list>
#include <cmath>
#include <cstdio>

using namespace std;

// d es distancia entre los centros de los circulos 

double areaintersectCircles(double r1, double r2, double d)
{
    if(d == 0 || d + r2 < r1 || d + r1 < r2)
        return min(M_PI * r1 * r1, M_PI * r2 * r2);
    double a = pow(r1, 2) * acos((pow(d, 2) + pow(r1, 2) - pow(r2, 2)) / (2 * d * r1));
    double b = pow(r2, 2) * acos((pow(d, 2) + pow(r2, 2) - pow(r1, 2)) / (2 * d * r2));
    double c = (sqrt((-d + r1 + r2) * (d + r1 - r2) * (d - r1 + r2) * (d + r1 + r2))) / 2;
    double respuesta = a + b - c;
    if(respuesta != respuesta)
        return 0;
    return respuesta;
}

bool circlesIntersect(double r1, double r2, double d)
{
	return r1 + r2 < d; // o <= dependiendo de la definicion
}

\end{verbatim}

\section{Convex Hull}

\subsection*{C}

\begin{verbatim}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>

using namespace std;

struct Point
{
    double x, y;
};

int n;

double dis(Point p1, Point p2)
{
    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}

double cross(Point p1, Point p2, Point p3)
{
    return (p2.x-p1.x)*(p3.y-p1.y) - (p2.y-p1.y)*(p3.x-p1.x);
}

bool comp(const Point &p1, const Point &p2)
{
    if(p1.y < p2.y) return true;
    if(p1.y > p2.y) return false;
    if(p1.x < p2.x) return true;
}

void getconvexhull(Point p1[], Point p2[], int &top)
{
    sort(p1, p1 + n, comp);
    int i;
    top = 0;
    p2[top++] = p1[0];
    p2[top++] = p1[1];
    for (i = 2; i < n; i++)
    {
        while (top >= 2 && cross(p2[top - 2], p2[top - 1], p1[i]) <= 0)
            --top;
        p2[top++] = p1[i];
    }
    int r = top;
    for (i = n - 2; i >= 0; i--)
    {
        while (top > r && cross(p2[top - 2], p2[top - 1], p1[i]) <= 0)
            --top;
        if (i != 0)
            p2[top++] = p1[i];
    }
}

/*
  Otra forma de verlo:
  vector<point> convex_hull(vector<point> ps) {
  int n = ps.size(), k = 0;
  sort(ps.begin(), ps.end());
  vector<point> ch(2*n);
  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull
    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;
  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull
    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;
  ch.resize(k-1);
  return ch;
}
*/

int main()
{
    int m, i;
    while (scanf("%d", &n) != EOF && n) {
        Point p1[105], p2[105];
        for (i = 0; i < n; i++)
            scanf("%lf%lf", &p1[i].x, &p1[i].y);
        if (n == 1) {
            printf("0.00\n");
            continue;
        }
        getconvexhull(p1, p2, m);
        double ans = 0.0;
        for (i = 0; i < m - 1; i++)
            ans += dis(p2[i], p2[i + 1]);
        ans += dis(p2[0], p2[m - 1]);
        printf("%.2lf\n", ans);
    }
    return 0;
}

\end{verbatim}

\subsection*{Java}

\begin{verbatim}

import java.awt.geom.Point2D;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.StringTokenizer;


public class Convex_Hull 
{
	static double cross(Point2D p1, Point2D p2, Point2D p3)
	{
	    return (p2.getX() - p1.getX()) * (p3.getY() - p1.getY()) - (p2.getY() - p1.getY()) * (p3.getX() - p1.getX());
	}

	static class Comp implements Comparator <Point2D>
	{
		@Override
		public int compare(Point2D p1, Point2D p2) 
		{
			if(p1.getY() < p2.getY()) return -1;
			if(p1.getY() > p2.getY()) return 1;
			if(p1.getX() < p2.getX()) return -1;
			return 1;
		}
	}

	static final double EPSILON = 1e-12;

	static void convexHull(List <Point2D> points, List <Point2D> result)
	{
		int n = points.size();
		Point2D[] p2 = new Point2D[points.size() + 1];
	    Collections.sort(points, new Comp());
	    int top = 0;
	    p2[top++] = points.get(0);
	    p2[top++] = points.get(1);
	    for (int i = 2; i < n; i++)
	    {
	        while (top >= 2 && cross(p2[top - 2], p2[top - 1], points.get(i)) <= -EPSILON)
	            --top;
	        p2[top++] = points.get(i);
	    }
	    int r = top;
	    for (int i = n - 2; i >= 0; i--)
	    {
	        while (top > r && cross(p2[top - 2], p2[top - 1], points.get(i)) <= -EPSILON)
	            --top;
	        if (i != 0)
	            p2[top++] = points.get(i);
	    }
	    for(int i = 0; i < top; i++)
	    	result.add(p2[i]);
	}
}

\end{verbatim}

\section{Great circle distance}

\begin{verbatim}

public class GCircleDist
{
	static double greatCircleDistance(double latitudeS, double longitudeS, double latitudeF, double longitudeF, double r)
	{
		latitudeS = Math.toRadians(latitudeS);
		latitudeF = Math.toRadians(latitudeF);
		longitudeS = Math.toRadians(longitudeS);
		longitudeF = Math.toRadians(longitudeF);
		double deltaLongitude = longitudeF - longitudeS;
		double a = Math.cos(latitudeF) * Math.sin(deltaLongitude);
		double b = Math.cos(latitudeS) * Math.sin(latitudeF);
		b -= Math.sin(latitudeS) * Math.cos(latitudeF) * Math.cos(deltaLongitude);
		double c = Math.sin(latitudeS) * Math.sin(latitudeF);
		c += Math.cos(latitudeS) * Math.cos(latitudeF) * Math.cos(deltaLongitude);
/*      En linea recta -> dist
        double ax = Math.cos(latitudeS) * Math.cos(longitudeS);
        double ay = Math.cos(latitudeS) * Math.sin(longitudeS);
        double az = Math.sin(latitudeS);
        double bx = Math.cos(latitudeF) * Math.cos(longitudeF);
        double by = Math.cos(latitudeF) * Math.sin(longitudeF); 
        double bz = Math.sin(latitudeF);
        double dist = r*Math.sqrt(sqr(ax-bx)+ sqr(ay-by)+sqr(az-bz));*/
		return Math.atan(Math.sqrt(a * a + b * b) / c) * r;
	}
	
/*	private static double sqr(double d) {
		return d * d;
	}
*/
	public static void main(String[] args)
	{
		System.out.println(greatCircleDistance(46, 87, 40, 89, 25000));
	}
}

\end{verbatim}

\section{Lines intersection}

\begin{verbatim}

import java.awt.geom.Point2D;
import java.io.IOException;
import java.util.Scanner;


public class Lines
{
	
	static Point2D interseccionLineas(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
	{
		double px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));
		double py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));
		return new Point2D.Double(px, py);
	}

// Esta implementado en Line2D - Distancia de un punto a un segmento

	double ptSegDist(double x1, double y1,
						 double x2, double y2,
						 double px, double py)
		{
			// Adjust vectors relative to x1,y1
			// x2,y2 becomes relative vector from x1,y1 to end of segment
			x2 -= x1;
			y2 -= y1;
			// px,py becomes relative vector from x1,y1 to test point
			px -= x1;
			py -= y1;
			double dotprod = px * x2 + py * y2;
			double projlenSq;
			if (dotprod <= 0.0) {
				// px,py is on the side of x1,y1 away from x2,y2
				// distance to segment is length of px,py vector
				// "length of its (clipped) projection" is now 0.0
				projlenSq = 0.0;
			} else {
				// switch to backwards vectors relative to x2,y2
				// x2,y2 are already the negative of x1,y1=>x2,y2
				// to get px,py to be the negative of px,py=>x2,y2
				// the dot product of two negated vectors is the same
				// as the dot product of the two normal vectors
				px = x2 - px;
				py = y2 - py;
				dotprod = px * x2 + py * y2;
				if (dotprod <= 0.0) {
				// px,py is on the side of x2,y2 away from x1,y1
				// distance to segment is length of (backwards) px,py vector
				// "length of its (clipped) projection" is now 0.0
				projlenSq = 0.0;
				} else {
				// px,py is between x1,y1 and x2,y2
				// dotprod is the length of the px,py vector
				// projected on the x2,y2=>x1,y1 vector times the
				// length of the x2,y2=>x1,y1 vector
				projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
				}
			}
			// Distance to line is now the length of the relative point
			// vector minus the length of its projection onto the line
			// (which is zero if the projection falls outside the range
			//  of the line segment).
			double lenSq = px * px + py * py - projlenSq;
			if (lenSq < 0) {
				lenSq = 0;
			}
			return sqrt(lenSq);
		}

	public static void main(String[] args) throws NumberFormatException, IOException
	{
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		System.out.println("INTERSECTING LINES OUTPUT");
		for(int i = 0; i < n; i++)
		{
			double x1 = sc.nextDouble();
			double y1 = sc.nextDouble();
			double x2 = sc.nextDouble();
			double y2 = sc.nextDouble();
			double x3 = sc.nextDouble();
			double y3 = sc.nextDouble();
			double x4 = sc.nextDouble();
			double y4 = sc.nextDouble();
			if(y2 - y1 == 0)
			{
				if(y4 - y3 == 0)
				{
					if(y1 == y3)
					{
						System.out.println("LINE");
					}
					else
					{
						System.out.println("NONE");
					}
				}
				else
				{
					Point2D interseccion = interseccionLineas(x1, y1, x2, y2, x3, y3, x4, y4);
					System.out.printf("POINT %.2d %.2d\n", interseccion.getX(), interseccion.getY());
				}
			}
			else
			{
				double ma = (x2 - x1) / (y2 - y1);
				double mb = (x4 - x3) / (y4 - y3);
				if(Math.abs(ma - mb) < 1e-6)
				{
					if(Math.abs((-y1 * ma + x1) - (-y3 * mb + x3)) < 1e-6)
					{
						System.out.println("LINE");
					}
					else
					{
						System.out.println("NONE");
					}
				}
				else
				{
					Point2D interseccion = interseccionLineas(x1, y1, x2, y2, x3, y3, x4, y4);
					System.out.printf("POINT %.2f %.2f\n", interseccion.getX(), interseccion.getY());
				}
			}
		}
		System.out.println("END OF OUTPUT");
	}

}

import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.StringTokenizer;

public class SegmentIntersect
{
	static class Scanner
	{
		BufferedReader br;
		StringTokenizer st;
		
		public Scanner()
		{
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		public String next()
		{

			while(st == null || !st.hasMoreTokens())
			{
				try { st = new StringTokenizer(br.readLine()); }
				catch(Exception e) { throw new RuntimeException(); }
			}
			return st.nextToken();
		}
		
		public int nextInt()
		{
			return Integer.parseInt(next());
		}
		
		public double nextDouble()
		{
			return Double.parseDouble(next());
		}
		
		public String nextLine()
		{
			st = null;
			try { return br.readLine(); }
			catch(Exception e) { throw new RuntimeException(); }
		}
	}
	
	public static Point2D.Double intersection( double x1,double y1,double x2,double y2, double x3, double y3, double x4,double y4 ) { double d = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4); if (d == 0) return null; double xi = ((x3-x4)*(x1*y2-y1*x2)-(x1-x2)*(x3*y4-y3*x4))/d; double yi = ((y3-y4)*(x1*y2-y1*x2)-(y1-y2)*(x3*y4-y3*x4))/d; if(x3==x4) { if ( yi < Math.min(y1,y2) || yi > Math.max(y1,y2) )return null; } Point2D.Double p = new Point2D.Double(xi,yi); if (xi < Math.min(x1,x2) || xi > Math.max(x1,x2)) return null; if (xi < Math.min(x3,x4) || xi > Math.max(x3,x4)) return null; return p; }
	
	static Point2D lineSegmentIntersection(
			double Ax, double Ay,
			double Bx, double By,
			double Cx, double Cy,
			double Dx, double Dy) {

			  double  distAB, theCos, theSin, newX, ABpos ;

			  //  Fail if either line segment is zero-length.
			  if (Ax==Bx && Ay==By || Cx==Dx && Cy==Dy) return null;

			  //  Fail if the segments share an end-point.
			  if (Ax==Cx && Ay==Cy || Bx==Cx && By==Cy
			  ||  Ax==Dx && Ay==Dy || Bx==Dx && By==Dy) {
			    return null; }

			  //  (1) Translate the system so that point A is on the origin.
			  Bx-=Ax; By-=Ay;
			  Cx-=Ax; Cy-=Ay;
			  Dx-=Ax; Dy-=Ay;

			  //  Discover the length of segment A-B.
			  distAB=Math.sqrt(Bx*Bx+By*By);

			  //  (2) Rotate the system so that point B is on the positive X axis.
			  theCos=Bx/distAB;
			  theSin=By/distAB;
			  newX=Cx*theCos+Cy*theSin;
			  Cy  =Cy*theCos-Cx*theSin; Cx=newX;
			  newX=Dx*theCos+Dy*theSin;
			  Dy  =Dy*theCos-Dx*theSin; Dx=newX;

			  //  Fail if segment C-D doesn't cross line A-B.
			  if (Cy<-EPSILON && Dy<-EPSILON || Cy>=-EPSILON && Dy>=-EPSILON) return null;

			  //  (3) Discover the position of the intersection point along line A-B.
			  ABpos=Dx+(Cx-Dx)*Dy/(Dy-Cy);

			  //  Fail if segment C-D crosses line A-B outside of segment A-B.
			  if (ABpos<-EPSILON || ABpos>distAB-EPSILON) return null;

			  //  (4) Apply the discovered position to line A-B in the original coordinate system.
			  double X=Ax+ABpos*theCos;
			  double Y=Ay+ABpos*theSin;

			  return new Point2D.Double(X, Y); }
	
	static Point2D interseccionAux(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
	{
		double px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));
		double py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));
		if(Math.abs(((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4))) < EPSILON)
			return null;
		if(Math.abs(((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4))) < EPSILON)
			return null;
		return new Point2D.Double(px, py);
	}

	static final double EPSILON = 0.00001;
	
	static Point2D PARALELAS = new Point2D.Double();
	
	static Point2D interseccionLineas(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
	{
		if(Math.abs(y2 - y1) < EPSILON)
		{
			if(Math.abs(y4 - y3) < EPSILON)
			{
				if(Math.abs(y1 - y3) < EPSILON)
					return PARALELAS;
				else
					return null;
			}
			else
				return interseccionAux(x1, y1, x2, y2, x3, y3, x4, y4);
		}
		else
		{
			double ma = (x2 - x1) / (y2 - y1);
			double mb = (x4 - x3) / (y4 - y3);
			if(Math.abs(ma - mb) < EPSILON)
			{
				if(Math.abs((-y1 * ma + x1) - (-y3 * mb + x3)) < EPSILON)
					return PARALELAS;
				else
					return null;
			}
			else
				return interseccionAux(x1, y1, x2, y2, x3, y3, x4, y4);
		}
	}
	
	static Point2D interseccionLineas(Line2D a, Line2D b)
	{
		return lineSegmentIntersection(a.getX1(), a.getY1(), a.getX2(), a.getY2(), b.getX1(), b.getY1(), b.getX2(), b.getY2());
	}
	
	static class PermutationGenerator {

	  private int[] a;
	  private BigInteger numLeft;
	  private BigInteger total;

	  //-----------------------------------------------------------
	  // Constructor. WARNING: Don't make n too large.
	  // Recall that the number of permutations is n!
	  // which can be very large, even when n is as small as 20 --
	  // 20! = 2,432,902,008,176,640,000 and
	  // 21! is too big to fit into a Java long, which is
	  // why we use BigInteger instead.
	  //----------------------------------------------------------

	  public PermutationGenerator (int n) {
	    if (n < 1) {
	      throw new IllegalArgumentException ("Min 1");
	    }
	    a = new int[n];
	    total = getFactorial(n);
	    reset ();
	  }

	  //------
	  // Reset
	  //------

	  public void reset () {
	    for (int i = 0; i < a.length; i++) {
	      a[i] = i;
	    }
	    numLeft = new BigInteger (total.toString ());
	  }

	  //------------------------------------------------
	  // Return number of permutations not yet generated
	  //------------------------------------------------

	  public BigInteger getNumLeft () {
	    return numLeft;
	  }

	  //------------------------------------
	  // Return total number of permutations
	  //------------------------------------

	  public BigInteger getTotal () {
	    return total;
	  }

	  //-----------------------------
	  // Are there more permutations?
	  //-----------------------------

	  public boolean hasMore () {
	    return numLeft.compareTo (BigInteger.ZERO) == 1;
	  }

	  //------------------
	  // Compute factorial
	  //------------------

	  private static BigInteger getFactorial (int n) {
	    BigInteger fact = BigInteger.ONE;
	    for (int i = n; i > 1; i--) {
	      fact = fact.multiply (new BigInteger (Integer.toString (i)));
	    }
	    return fact;
	  }

	  //--------------------------------------------------------
	  // Generate next permutation (algorithm from Rosen p. 284)
	  //--------------------------------------------------------

	  public int[] getNext () {

	    if (numLeft.equals (total)) {
	      numLeft = numLeft.subtract (BigInteger.ONE);
	      return a;
	    }

	    int temp;

	    // Find largest index j with a[j] < a[j+1]

	    int j = a.length - 2;
	    while (a[j] > a[j+1]) {
	      j--;
	    }

	    // Find index k such that a[k] is smallest integer
	    // greater than a[j] to the right of a[j]

	    int k = a.length - 1;
	    while (a[j] > a[k]) {
	      k--;
	    }

	    // Interchange a[j] and a[k]

	    temp = a[k];
	    a[k] = a[j];
	    a[j] = temp;

	    // Put tail end of permutation after jth position in increasing order

	    int r = a.length - 1;
	    int s = j + 1;

	    while (r > s) {
	      temp = a[s];
	      a[s] = a[r];
	      a[r] = temp;
	      r--;
	      s++;
	    }

	    numLeft = numLeft.subtract (BigInteger.ONE);
	    return a;

	  }

	}
	
	static class Punto
	{
		Point2D p;
		
		public Punto(Point2D pp) 
		{
			p = pp;
		}

		@Override
		public boolean equals(Object obj) 
		{
			Punto otro = (Punto) obj;
			if(Math.abs(p.getX() - otro.p.getX()) > EPSILON)
				return false;
			if(Math.abs(p.getY() - otro.p.getY()) > EPSILON)
				return false;
			return true;
		}
	}
	
	static int n, c;
	static int[][] costo = new int[20][20];
	static Punto[] ciudades = new Punto[20];
	
	public static void main(String[] args)
	{
		Scanner sc = new Scanner();
		int caso = 1;
		while(true)
		{
			n = sc.nextInt();
			c = sc.nextInt();
			if(n == 0 && c == 0)
				return;
			for(int i = 0; i < n; i++)
			{
				int x = sc.nextInt();
				int y = sc.nextInt();
				ciudades[i] = new Punto(new Point2D.Double(x, y));
			}
			for(int i = 0; i < n; i++)
				for(int j = 0; j < n; j++)
					costo[i][j] = sc.nextInt();
			PermutationGenerator pg = new PermutationGenerator(n);
			int mejor = Integer.MAX_VALUE;
			while(pg.hasMore())
				mejor = Math.min(mejor, intentar(pg.getNext()));
			System.out.println(caso++ + ". " + mejor);
		}
	}

	static class Interseccion
	{
		Punto p;
		ArrayList <Line2D> lineas = new ArrayList <Line2D> ();
		
		public Interseccion(Punto pp, Line2D primera, Line2D segunda)
		{
			p = pp;
			lineas.add(primera);
			lineas.add(segunda);
		}
	}
	
	private static int intentar(int[] next) 
	{
		ArrayList <Line2D> lineas = new ArrayList <Line2D> ();
		LinkedList <Interseccion> intersecciones = new LinkedList <Interseccion> ();
		int costoT = 0;
		for(int i = 1; i <= next.length; i++)
		{
			costoT += costo[next[i - 1]][next[i % next.length]];
			Line2D.Double nueva = new Line2D.Double(ciudades[next[i - 1]].p, ciudades[next[i % next.length]].p);
			for(Line2D l : lineas)
			{
				if(nueva.getP1().equals(l.getP1()) || nueva.getP1().equals(l.getP2()) || nueva.getP2().equals(l.getP1()) || nueva.getP2().equals(l.getP2()))
					continue;
				if(!l.intersectsLine(nueva))
					continue;
				Point2D inter = interseccionLineas(l, nueva);
				if(inter == null)
					continue;
				Punto punto = new Punto(inter);
				boolean esta = false;
				for(Interseccion in : intersecciones)
				{
					if(in.p.equals(punto))
					{
						if(!in.lineas.contains(nueva))
							in.lineas.add(nueva);
						esta = true;
					}
				}
				if(!esta)
					intersecciones.add(new Interseccion(punto, nueva, l));
			}
			lineas.add(nueva);
		}
		for(Interseccion in : intersecciones)
			costoT += (in.lineas.size() * (in.lineas.size() - 1) * c) / 2;
		return costoT;
	}
}

\end{verbatim}

\subsection{Polygon}

\begin{verbatim}

import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.TreeSet;

public class Polygon
{
	static class Polygon
	{
		ArrayList <Line2D> lines;
		Point2D anterior = null;
		
		public Polygon(int minSize)
		{
			lines = new ArrayList <Line2D> (minSize); 
		}
		
		public void add(Point2D nuevo)
		{
			if(anterior != null)
			{
				lines.add(new Line2D.Double(anterior, nuevo));
			}
			anterior = nuevo;
		}
		
		public void close()
		{
			lines.add(new Line2D.Double(anterior, lines.get(0).getP1()));
		}
		
		public static Point2D subtract(Point2D a, Point2D b)
		{
			return new Point2D.Double(a.getX() - b.getX(), a.getY() - b.getY());
		}
		
		static double abs(Point2D a)
		{
			return Math.sqrt(a.getX() * a.getX() + a.getY() * a.getY());
		}
		
		static double cross(Point2D a, Point2D b) 
		{
			return (a.getX() * b.getY()) - (a.getY() * b.getX());
		}
		
		static boolean is_point_online(Point2D a, Point2D b, Point2D c)
		{
			return abs(subtract(a, c)) + abs(subtract(b, c)) <= abs(subtract(a, b));
		}

		// Ya esta implementado en ((Line2D) lineA).intersectsLine(lineB)
		public static boolean lines_intersect(Line2D a, Line2D b)
		{
			return cross(subtract(a.getP2(), a.getP1()), subtract(b.getP1(), a.getP1())) *
				   cross(subtract(a.getP2(), a.getP1()), subtract(b.getP2(), a.getP1())) < 0 && 
				   cross(subtract(b.getP2(), b.getP1()), subtract(a.getP1(), b.getP1())) *
				   cross(subtract(b.getP2(), b.getP1()), subtract(a.getP2(), b.getP1())) < 0;
		}
		
		// Funciona para cualquier poligono excepto si es self-intersecting
		public double area() 
		{
			double area = 0;
			for (Line2D line : lines) 
			{
				area += line.getP1().getX() * line.getP2().getY();
				area -= line.getP2().getX() * line.getP1().getY();
			}
			area /= 2.0;
			return Math.abs(area);
		}

		// Funciona para cualquier poligono excepto si es self-intersecting
		public double areaUnsigned() 
		{
			double area = 0;
			for (Line2D line : lines) 
			{
				area += line.getP1().getX() * line.getP2().getY();
				area -= line.getP2().getX() * line.getP1().getY();
			}
			area /= 2.0;
			return area;
		}

		// Funciona para cualquier poligono excepto si es self-intersecting
		public Point2D centerOfMass() 
		{
			double cx = 0, cy = 0;
			double area = areaUnsigned();
			double factor = 0;
			for (Line2D line : lines) 
			{
				factor = line.getP1().getX() * line.getP2().getY() - line.getP2().getX() * line.getP1().getY();
				cx += (line.getP1().getX() + line.getP2().getX()) * factor;
				cy += (line.getP1().getY() + line.getP2().getY()) * factor;
			}
			area *= 6.0d;
			factor = 1 / area;
			cx *= factor;
			cy *= factor;
			return new Point2D.Double(cx, cy);
		}
		
		public boolean intersects(Polygon other)
		{
			for(Line2D lineA : lines)
			{
				if(other.contains(lineA.getP1()))
					return true;
				for(Line2D lineB : other.lines)
				{
					if(lineA.intersectsLine(lineB))
						return true;
				}
			}
			for(Line2D line : other.lines)
			{
				if(contains(line.getP1()))
					return true;
			}
			return false;
		}
		
		public boolean contains(Point2D p)
		{
			  int cnt = 0;
			  for(Line2D line : lines)
			  {
			    Point2D curr = subtract(line.getP1(), p);
			    Point2D next = subtract(line.getP2(), p);
			    if(curr.getY() > next.getY())
			    {
			    	Point2D temp = curr;
			    	curr = next;
			    	next = temp;
			    }
			    if (curr.getY() < 0 && 0 <= next.getY() && cross(next, curr) >= 0)
			    {
			    	cnt++;
			    }
			    if (is_point_online(line.getP1(), line.getP2(), p))
			    		return true;
			  }
			  return  cnt % 2 == 1;
		}
	}
	
	static class DisjointSet
	{
		int[] p, rank;

		public DisjointSet(int size)
		{
			rank = new int[size];
			p = new int[size];
			for(int i = 0; i < size; i++)
			{
				make_set(i);
			}
		}

		public void make_set(int x)
		{
			p[x] = x;
			rank[x] = 0;
		}

		public void merge(int x, int y)
		{
			link(find_set(x), find_set(y));
		}

		public void link(int x, int y)
		{
			if(rank[x] > rank[y])
				p[y] = x;
			else
			{
				p[x] = y;
				if (rank[x] == rank[y])
					rank[y] += 1;
			}
		}

		public int find_set(int x)
		{
			if (x != p[x])
				p[x] = find_set(p[x]);
			return p[x];
		}
	}

	public static void main(String[] args) throws NumberFormatException, IOException
	{
		int n = 0;
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		while((n = Integer.parseInt(br.readLine())) != 0)
		{
			LinkedList <Polygon> poligonos = new LinkedList <Polygon> ();
			for(int i = 0; i < n; i++)
			{
				String[] linea = br.readLine().split(" ");
				Polygon poligono = new Polygon(10);
				for(int j = 0; j < linea.length; j += 2)
				{
					poligono.add(new Point2D.Double(Double.parseDouble(linea[j]), Double.parseDouble(linea[j + 1])));
				}
				poligono.close();
				poligonos.add(poligono);
			}
			DisjointSet dj = new DisjointSet(poligonos.size());
			int i = 0;
			for(Polygon a : poligonos)
			{
				int j = 0;
				for(Polygon b : poligonos)
				{
					if(dj.find_set(i) == dj.find_set(j))
					{
						j++;
						continue;
					}
					if(a.intersects(b))
					{
						dj.merge(i, j);
					}
					j++;
				}
				i++;
			}
			TreeSet <Integer> set = new TreeSet <Integer> ();
			for(i = 0; i < poligonos.size(); i++)
				set.add(dj.find_set(i));
			System.out.println(set.size());
		}
	}
}

\end{verbatim}

\subsection{SEC}

\begin{verbatim}

import java.awt.geom.Point2D;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.math.BigDecimal;
import java.util.ArrayList;


public class SEC
{
	static class Circle  
	{
	    private Point2D p;
	    private double r;
	    
		public Circle()
	    {
			p = new Point2D.Double(0,0);
			r = 0;
	    }
		
		public Circle(Circle circle)
	    {
			p = new Point2D.Double(circle.p.getX(), circle.p.getY());
			r = circle.r;
	    }
		
		public Circle(Point2D center, double radius)
	    {
			p = new Point2D.Double(center.getX(), center.getY());
			r = radius;
	    }
		
		public Circle(Point2D center)
	    {
			p = new Point2D.Double(center.getX(), center.getY());
			r = 0;
	    }
		
	    public static Point2D midPoint(Point2D a, Point2D b)
	    {
			return new Point2D.Double((a.getX() + b.getX()) / 2, (a.getY() + b.getY()) / 2);
	    }
	    
	    public Circle(Point2D p1, Point2D p2)
	    {
			p = midPoint(p1, p2);
			r = p1.distance(p);
	    }
	    
	    public Circle(Point2D p1, Point2D p2, Point2D p3)
	    {
			try
			{
				double x = (p3.getX()
						* p3.getX()
						* (p1.getY() - p2.getY())
						+ (p1.getX() * p1.getX() + (p1.getY() - p2.getY())
								* (p1.getY() - p3.getY()))
						* (p2.getY() - p3.getY()) + p2.getX() * p2.getX()
						* (-p1.getY() + p3.getY()))
						/ (2 * (p3.getX() * (p1.getY() - p2.getY()) + p1.getX()
								* (p2.getY() - p3.getY()) + p2.getX()
								* (-p1.getY() + p3.getY())));
				double y = (p2.getY() + p3.getY()) / 2
						- (p3.getX() - p2.getX()) / (p3.getY() - p2.getY())
						* (x - (p2.getX() + p3.getX()) / 2);
				p = new Point2D.Double(x, y);
				r = p.distance(p1);
				if(Double.isInfinite(r) || Double.isInfinite(x) || Double.isInfinite(y) || Double.isNaN(r) || Double.isNaN(x) || Double.isNaN(y))
				{	
					r = 0;
					p = new Point2D.Double(0, 0);
				}
			}
			catch(Exception e)
			{
			}	
	    }
	    
		public Point2D getCenter()
		{
			return p;
		}
		
		public double getRadius()
		{
			return r;
		}
		
		public void setCenter(Point2D center)
		{
			p.setLocation(center);
		}
		
		public void setRadius(double radius)
		{
			r = radius;
		}
		
	    public void translate(Point2D newCenter)
	    {
			p.setLocation(newCenter);
	    }    
	    
	    public void offset(double dr)
	    {
			r += dr;
	    }
	    
	    public void scale(double factor)
	    {
			r *= factor;
	    }
	    
	    public double getDiameter()
	    {
			return (2 * r);
	    }
	    
	    public double getCircumference()
	    {
			return (Math.PI * 2 * r);
	    }
	    
	    public double getArea()
	    {
			return (Math.PI * r * r);
	    }
	    
		public int contain(Point2D point)
		{
			int answer = 0;
			double d = p.distance(point);
			if (d > r)
			{
				answer = 1;		// The point is outside the circle
			}
			else if (d == r)
			{
				answer = 0;		// The point is on the circumference of the circle
			}
			else
			{
				answer = -1;	// The point is inside the circle
			}
			return answer;
		}
			
	    public boolean equals(Circle circle)
	    {
			return p.equals(circle.p) && (r == circle.r);
	    }
	}

	
	public static Circle sec(ArrayList <Point2D> a)
	{
		Point2D[] p = new Point2D[a.size()];
		a.toArray(p);
		return findSec(a.size(), p, 0, new Point2D[3]);
	}
	
	// Compute the Smallest Enclosing Circle of the n points in p, 
	// such that the m points in B lie on the boundary of the circle.
	public static Circle findSec(int n, Point2D[] p, int m, Point2D[] b)
	{
		Circle sec = new Circle();
		if(m == 1)
		{
			sec = new Circle(b[0]);
		}
		else if(m == 2)
		{
			sec = new Circle(b[0], b[1]);
		}
		else if(m == 3)
		{
			return new Circle(b[0], b[1], b[2]);
		}
		for(int i=0; i < n; i++)
		{
			if(sec.contain(p[i]) == 1)
			{
				b[m] = new Point2D.Double();
				b[m].setLocation(p[i]);
				sec = findSec(i, p, m + 1, b);
			}
		}
		return sec;
	}	
	
	public static void main(String[] args) throws IOException
	{

		System.setIn(new FileInputStream("c.in"));
		System.setOut(new PrintStream("c.sol"));
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		while(true)
		{
			int numero = Integer.parseInt(br.readLine());
			if(numero == 0)
				return;
			ArrayList <Point2D> puntos = new ArrayList <Point2D> (numero);
			for(int i = 0; i < numero; i++)
			{
				String[] pedazos = br.readLine().split(" ");
				double x = java.lang.Double.parseDouble(pedazos[0]);
				double y = java.lang.Double.parseDouble(pedazos[1]);
				puntos.add(new Point2D.Double(x, y));
			}
			Circle circulo = sec(puntos);
			System.out.printf("%s %s %s\n", new BigDecimal(circulo.p.getX()).divide(BigDecimal.ONE, 2, BigDecimal.ROUND_HALF_EVEN), new BigDecimal(circulo.p.getY()).divide(BigDecimal.ONE, 2, BigDecimal.ROUND_HALF_EVEN), new BigDecimal(circulo.r).divide(BigDecimal.ONE, 2, BigDecimal.ROUND_HALF_EVEN));
		}
	}
}

\end{verbatim}

\chapter{Grafos}

\section{Bipartite Coloring}

In the mathematical field of graph theory, a bipartite graph (or bigraph) is a graph whose vertices can be divided into two disjoint sets U and V such that every edge connects a vertex in U to one in V; that is, U and V are independent sets. Equivalently, a bipartite graph is a graph that does not contain any odd-length cycles.
The two sets U and V may be thought of as a coloring of the graph with two colors: if we color all nodes in U blue, and all nodes in V green, each edge has endpoints of differing colors, as is required in the graph coloring problem. In contrast, such a coloring is impossible in the case of a nonbipartite graph, such as a triangle: after one node is colored blue and another green, the third vertex of the triangle is connected to vertices of both colors, preventing it from being assigned either color.
One often writes G = (U, V, E) to denote a bipartite graph whose partition has the parts U and V. If |U| =|V|, that is, if the two subsets have equal cardinality, then G is called a balanced bipartite graph.

Any graph with no odd cycles is bipartite. As a consequence of this:
Every tree is bipartite.
Cycle graphs with an even number of vertices are bipartite.
Any planar graph where all the faces in its planar representation consist of an even number of edges is bipartite. Special cases of this are grid graphs and squaregraphs, in which every inner face consists of 4 edges.

If a bipartite graph is connected, its bipartition can be defined by the parity of the distances from any arbitrarily chosen vertex v: one subset consists of the vertices at even distance to v and the other subset consists of the vertices at odd distance to v.
Thus, one may efficiently test whether a graph is bipartite by using this parity technique to assign vertices to the two subsets U and V, separately within each connected component of the graph, and then examine each edge to verify that it has endpoints assigned to different subsets.

\begin{verbatim}

public class Bipartite_Coloring
{
	static int[][] conexiones = new int[100][100];
	
	static class Nodo
	{
		int numero;
		
		public Nodo(int n, int todas)
		{
			numero = n;
			for(int i = 0; i < todas; i++)
			{
				conexiones[n][i] = -1;
				conexiones[i][n] = -1;
			}
		}
		
		public void agregarArista(Arista nueva)
		{
			Nodo otro = nueva.a == this ? nueva.b : nueva.a;
			conexiones[numero][otro.numero] = nueva.numero;
			conexiones[otro.numero][numero] = nueva.numero;
		}

		public boolean estaConectado(Nodo b) 
		{
			return conexiones[numero][b.numero] >= 0;
		}
	}
	
	static class DisjointSet
	{
		int[] p, rank;

		public DisjointSet(int size)
		{
			rank = new int[size];
			p = new int[size];
			for(int i = 0; i < size; i++)
			{
				make_set(i);
			}
		}

		public void make_set(int x)
		{
			p[x] = x;
			rank[x] = 0;
		}

		public void merge(int x, int y)
		{
			link(find_set(x), find_set(y));
		}

		public void link(int x, int y)
		{
			if(rank[x] > rank[y])
				p[y] = x;
			else
			{
				p[x] = y;
				if (rank[x] == rank[y])
					rank[y] += 1;
			}
		}

		public int find_set(int x)
		{
			if (x != p[x])
				p[x] = find_set(p[x]);
			return p[x];
		}

		public void iniciar(int m) 
		{
			for(int i = 0; i < m; i++)
			{
				make_set(i);
			}
		}
	}
	
	static class Arista
	{
		Nodo a;
		Nodo b;
		int numero;
		public Aristas set;
		
		public Arista(Nodo a1, Nodo b1, int n)
		{
			a = a1;
			b = b1;
			numero = n;
		}
	}
	
	static class ParAristas
	{
		Arista a;
		Arista b;
		
		public ParAristas(Arista a1, Arista b1)
		{
			a = a1;
			b = b1;
		}
	}
	
	static class Aristas
	{
		ArrayList <Arista> aristas = new ArrayList <Arista> ();
		ArrayList <Aristas> adjacentes = new ArrayList <Aristas> ();
		int color = 0;
	}
	
	static Nodo[] nodos = new Nodo[100];
	static Arista[] aristas = new Arista[1000];
	static DisjointSet ds = new DisjointSet(1000);
	static Aristas[] aristasProblema = new Aristas[1000];
	
	public static void main(String [] args)
	{
		Scanner sc = new Scanner();
		while(true)
		{
			int n = sc.nextInt();
			if(n == 0)
				return;
			int m = sc.nextInt();
			if(n == 0 && m == 0)
				return;
			for(int i = 0; i < n; i++)
				nodos[i] = new Nodo(i, n);
			for(int i = 0; i < m; i++)
			{
				Arista nueva = new Arista(nodos[sc.nextInt()], nodos[sc.nextInt()], i);
				nueva.a.agregarArista(nueva);
				nueva.b.agregarArista(nueva);
				aristas[i] = nueva;
				aristasProblema[i] = null;
			}
			ds.iniciar(m);
			ArrayList <ParAristas> pares = new ArrayList <ParAristas> ();
			for(int i = 0; i < n; i++)
			{
				Nodo a = nodos[i];
				for(int j = 0; j < n; j++)
				{
						if(conexiones[i][j] < 0)
							continue;
						for(int k = 0; k < n; k++)
						{
							if(conexiones[j][k] < 0)
								continue;
							Nodo c = nodos[k];
							if(c == a)
								continue;
							if(a.estaConectado(c))
								ds.merge(conexiones[i][j], conexiones[j][k]);
							else
								pares.add(new ParAristas(aristas[conexiones[i][j]], aristas[conexiones[j][k]]));
						}
				}
			}
			for(int i = 0; i < m; i++)
			{
				Arista actual = aristas[i];
				int numero = ds.find_set(i);
				if(aristasProblema[numero] != null)
				{
					aristasProblema[numero].aristas.add(actual);
				}
				else
				{
					aristasProblema[numero] = new Aristas();
					aristasProblema[numero].aristas.add(actual);
				}
			}
			for(int i = 0; i < m; i++)
			{
				if(aristasProblema[i] == null)
					continue;
				Aristas actual = aristasProblema[i];
				for(Arista a : actual.aristas)
					a.set = actual;
			}
			for(ParAristas p : pares)
			{
				p.a.set.adjacentes.add(p.b.set);
				p.b.set.adjacentes.add(p.a.set);
			}
			boolean bien = true;
			for(int i = 0; i < m; i++)
			{
				Aristas a = aristasProblema[i];
				if(a == null)
					continue;
				if(a.color == 0)
					if(!pintar(a, 1))
					{
						bien = false;
						break;
					}
			}
			if(bien)
				System.out.println("YES");
			else
				System.out.println("NO");
		}
	}

	private static boolean pintar(Aristas a, int i) 
	{
		a.color = i;
		for(Aristas hija : a.adjacentes)
		{
			if(hija.color > 0)
			{
				if(hija.color == i)
					return false;
			}
			else
			{
				if(!pintar(hija, i == 1 ? 2 : 1))
					return false;
			}
		}
		return true;
	}
}

\end{verbatim}

\section{Cycle detect}

\subsection*{C}

\begin{verbatim}

#include <iostream>
#include <list>

#define MAX 20005
#define LOOP 0x20000
#define DEL 0x10000

using namespace std;

list<int> hijos[MAX];
list<int> padres[MAX];
int numPadres[MAX];
int group[MAX];
int N, cgroup;

void init() {
	for (int i=0; i<N; i++) {
		hijos[i].clear(); padres[i].clear();
		numPadres[i]=0;
		group[i]=0;
	}
	cgroup=0;
}

//Creates a tree with the given root
void newtree(int root) {
	group[root] = cgroup;
	list<int> *act = &hijos[root];
	if (act->empty()) return;
	list<int>::iterator it;
	for (it=act->begin(); it != act->end(); it++) {
		if ((group[*it] & 0x1FFFF) == 0) newtree(*it);
	}
}

//Removes the loop given the original node that belongs to the loop
//and return the number of fathers of the new node
int remLoop(int orgNode) {
	int node=orgNode,father,nump=0;
	padres[N].clear(); hijos[N].clear();
	do {
		father = group[node] & 0xFFFF;
		group[node] = DEL | LOOP;
		list<int>::iterator it;
		list<int> *act = &padres[node];
		for (it=act->begin(); it != act->end(); it++) {
			//If node *it isn't in Loop add as father to new node 
			if ((group[*it] & LOOP) == 0) {
				 padres[N].push_back(*it);
				 hijos[*it].push_back(N);
				 nump++;
			}
		}
		act = &hijos[node];
		for (it=act->begin(); it != act->end(); it++) {
			//If node *it isn't in Loop add as son to new node 
			if ((group[*it] & LOOP) == 0) {
				hijos[N].push_back(*it);
				padres[*it].push_back(N);
			}
		}
		node = father;
	} while (node != orgNode);
	group[N]=0;
	N++;
	return nump;
}

int subtrees() {
	for (int i=0; i<N; i++) {
		if (numPadres[i]==0) {
			cgroup++;
			newtree(i);
		}
	}
	for (int i=0; i<N; i++) {
		while (group[i] == 0) {
			int node, father;
			node=i;
			while ((group[node] & LOOP) == 0) {
				while (true) {
					father = padres[node].front();
					if ((group[father] & DEL) == 0) break;
					padres[node].pop_front();
				}
				group[node] = LOOP | father;
				node = father;
			}
			//Loop found, remove from look other nodes
			int rnode=i;
			while (rnode != node) {
				father = group[rnode] & 0xFFFF;
				group[rnode]=0;
				rnode = father;
			}				
			if (remLoop(node) == 0) {
				//Now, N-1 is the root
				cgroup++;
				newtree(N-1);
			}
		}
	}
	return cgroup;
}

int main() {
	int T,M;
	int a,b; //Connection from a to b
	cin >> T;
	for (int c=1; c<=T; c++) {
		cin >> N >> M;
		init();
		for (int i=0; i<M; i++) {
			cin >> a >> b;
			a--; b--;
			hijos[a].push_back(b);
			padres[b].push_back(a);
			numPadres[b]++;
		}
		cout << "Case " << c << ": " << subtrees() << endl;
	}
	//cout << endl;
}

\end{verbatim}

\subsection*{Java}

\begin{verbatim}

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.TreeMap;


public class Cycle_Detect
{
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

	static class Arista
	{
		Nodo otro;
		Nodo anterior;
		boolean borrada = false;
		
		public Arista(Nodo o, Nodo a)
		{
			otro = o;
			anterior = a;
		}
	}
	
	static class Nodo implements Comparable <Nodo>
	{
		String nombre;
		ArrayList <Arista> adjacentes = new ArrayList <Arista> ();
		Persona persona;
        int lowlink = -1; 
        int index = -1;
		
		public Nodo(String n, Persona p)
		{
			nombre = n;
			persona = p;
		}
		
        public int compareTo(final Nodo argNode) 
        {
            return argNode == this ? 0 : -1;
        }
        @Override
        public boolean equals(Object obj)
        {
        	return nombre.equals(((Nodo) obj).nombre);
        }
	}
	
	static class Persona
	{
		TreeMap <String, Nodo> nodos = new TreeMap <String, Nodo> ();
		ArrayList <Arista> aristas = new ArrayList <Arista> ();
		
		public boolean solucionarErrores()
		{
			for(Arista a : aristas)
			{
				a.borrada = true;
				if(verificarConsistencia())
					return true;
				a.borrada = false;
			}
			return false;
		}
		
		public boolean verificarConsistencia()
		{
			for(Nodo n : nodos.values())
			{
				n.lowlink = -1; 
		        n.index = -1;
			}
			index = 0;
			stack = new ArrayList <Nodo> ();
			si = false;
			for(Nodo n : nodos.values())
			{
	            if(n.index == -1)
	            {	
	            	tarjan(n);
	            }
			}
			return !si;
		}

		public Nodo buscar(String string) 
		{
			if(!nodos.containsKey(string))
				nodos.put(string, new Nodo(string, this));
			return nodos.get(string);
		}
		
		public void llenar() throws IOException
		{
			String[] preferencias = br.readLine().split("(\\s*,\\s*) | (\\s*;\\s*)");
			for(String f : preferencias)
			{
				String[] preferenciasAA = f.split("\\s+");
				Nodo anterior = buscar(preferenciasAA[0]);
				for(int i = 1; i < preferenciasAA.length; i++)
				{
					Nodo actual = buscar(preferenciasAA[i]);
					Arista nueva = new Arista(actual, anterior);
					anterior.adjacentes.add(nueva);
					aristas.add(nueva);
					anterior = actual;
				}	
			}
		}
	}
	
	static int index;
    static ArrayList <Nodo> stack;
    static boolean si = false;
	
	public static void tarjan(Nodo v)
	{
	     v.index = index;
	     v.lowlink = index;
	     index++;
	     stack.add(0, v);
	     for(Arista a : v.adjacentes)
	     {
	    	 if(a.borrada)
	    		 continue;
	    	 Nodo n = a.otro;
	    	 if(n.index == -1)
	    	 {
	    		 tarjan(n);
	    		 v.lowlink = Math.min(v.lowlink, n.lowlink);
	    	 }
	    	 else if(stack.contains(n))
	    		 v.lowlink = Math.min(v.lowlink, n.index);
	     }
	     if(v.lowlink == v.index)
	     {
	    	 Nodo n;
	    	 int cuenta = 0;
             do
             {
                 n = stack.remove(0);
                 cuenta++;
             }
             while(n != v);
             si = si || cuenta != 1;
	     }
	}
	
	public static void main(String[] args) throws IOException
	{
		while(true)
		{
			String[] nombres = br.readLine().split(" ");
			if(nombres[0].equals("*") && nombres[1].equals("*"))
				return;
			Persona a = new Persona();
			a.llenar();
			a.llenar();
			if(a.verificarConsistencia())
				System.out.println("F");	
			else if(a.solucionarErrores())
				System.out.println("P");	
			else
				System.out.println("N");
		}
	}
}

\end{verbatim}

\section{Ford Fulkerson}

\begin{verbatim}

import java.io.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class Ford_Fulkerson
{
	int	n,m;
	int	snode,tnode;	/* start node, terminate node */
	int	step;
	boolean termino = false;
	Node	v[] = new Node[98];
	Edge	e[] = new Edge[2048];

	void input_graph(Scanner sc) throws IOException 
	{
		int edges = 0;
		n = sc.nextInt();
		m = sc.nextInt();
		if(n == m && n == 0)
		{
			termino = true;
			return;
		}
		v = new Node[98];
		e = new Edge[2048];
		v[0] = new Node();
		v[0].name = 0;
		for (int i = 1; i < n - 1; i++) 
		{
			Node node = new Node();
			node.name = sc.nextInt() - 1;
			int peso = sc.nextInt();
			Node node2 = new Node();
			node2.name = node.name + (n - 2);
			Edge edge = new Edge();
			edge.rndd_plus = node.name;
			edge.rndd_minus = node2.name;
			edge.capacity = peso;
			edge.flow = 0;
			e[edges] = edge;
			edges++;
			v[node.name] = node;
			v[node2.name] = node2;
		}
		v[(((n - 2) * 2) + 1)] = new Node();
		v[(((n - 2) * 2) + 1)].name = (((n - 2) * 2) + 1);
		if(m == 0)
		{
			return;
		}
		for (int i = 0; i < m; i++) 
		{
			Edge edge = new Edge();
			int ent = sc.nextInt() - 1;
			int sal = sc.nextInt() - 1;
			edge.rndd_plus = ent == 0 ? ent : (ent + (n - 2));
			edge.rndd_minus = sal == n - 1 ? (((n - 2) * 2) + 1) : sal;
			edge.capacity = sc.nextInt();
			edge.flow = 0;
			if(sal != (n - 1) && ent != 0)
			{
				Edge edge2 = new Edge();
				edge2.rndd_plus = (sal + (n - 2));
				edge2.rndd_minus = ent;
				edge2.flow = 0;
				edge2.capacity = edge.capacity;
				e[edges] = edge2;
				edges++;
			}
			e[edges] = edge;
			edges++;
		}
		e = Arrays.copyOf(e, edges);
		m = edges;
		Arrays.sort(e, new Comparador());
		step = 1;
	}

	void rdb() 
	{
		int	i,k;
		for (i=0; i<n; i++)
			v[i].delta_plus = v[i].delta_minus = -1;
		for (i=0; i<m; i++)
			e[i].delta_plus = e[i].delta_minus = -1;
		for (i=0; i<m; i++) 
		{
			k = e[i].rndd_plus;
			if (v[k].delta_plus == -1)
				v[k].delta_plus = i;
			else 
			{
				k = v[k].delta_plus;
				while(e[k].delta_plus >= 0)
					k = e[k].delta_plus;
				e[k].delta_plus = i;
			}
			k = e[i].rndd_minus;
			if (v[k].delta_minus == -1)
				v[k].delta_minus = i;
			else 
			{
				k = v[k].delta_minus;
				while(e[k].delta_minus >= 0)
					k = e[k].delta_minus;
				e[k].delta_minus = i;
			}
		}
	}

	void stpath()
	{	
		int	u[] = new int[98], ni, no;
		int	i,j,d;
		for (i=0; i<n; i++) 
		{
			v[i].prev = v[i].dist = -1;
			v[i].l = 0;
		}
		for (i=0; i<m; i++)
			e[i].st = -1;
		ni = no = 0;
		d = 0;
		u[ni] = snode;
		v[snode].dist = 0;
		j = v[snode].delta_plus;
		i = 0;
		while (j>=0) 
		{
			if (i<e[j].capacity)
				i = e[j].capacity;
			j = e[j].delta_plus;
		}
		v[snode].l = i;
		for (; no<=ni; no++) 
		{
			d = v[u[no]].dist;
			for (j=v[u[no]].delta_plus; j>=0; j=e[j].delta_plus)
			{
				if (e[j].capacity-e[j].flow == 0)
					continue;
				i = e[j].rndd_minus;
				if (v[i].dist<0)
				{
					v[i].dist = d+1;
					v[i].prev = u[no];
					v[i].p_edge = j;
					v[i].l = Math.min(v[u[no]].l,
						e[j].capacity-e[j].flow);
					e[j].st++;
					u[++ni] = i;
				}
			}
			for (j=v[u[no]].delta_minus; j>=0; j=e[j].delta_minus) 
			{
				if (e[j].flow == 0)
					continue;
				i = e[j].rndd_plus;
				if (v[i].dist<0)
				{
					v[i].dist = d+1;
					v[i].prev = u[no];
					v[i].p_edge = j;
					v[i].l = Math.min(v[u[no]].l,e[j].flow);
					e[j].st++;
					u[++ni] = i;
				}
			}
		}
	}

	void step0() 
	{
		for (int i=0; i<m; i++)
			e[i].flow = 0;
		stpath();
	}

	void step1() 
	{		
		int	i;
		if (v[tnode].dist<0)
			return;
		for (i = tnode; v[i].prev>=0; i=v[i].prev )
			e[v[i].p_edge].st++;
	}

	void step2() 
	{
		int	i,j,a,f;
		f = v[tnode].l;
		for (i = tnode; (j=v[i].prev)>=0; i = j) 
		{
			a = v[i].p_edge;
			if (e[a].rndd_minus==i)
				e[a].flow += f;
			else if (e[a].rndd_plus==i)
				e[a].flow -= f;
		}
		stpath();
	}

	public void init() 
	{
		try 
		{

//			InputStream is = new FileInputStream("angry.in");
			InputStream is = System.in;
			Scanner sc = new Scanner(is);
			for(;;)
			{
				input_graph(sc);
				if(termino)
				{
					return;
				}
				if(m == 0)
				{
					System.out.println("0");
					continue;
				}
				snode = 0;
				tnode = (((n - 2) * 2) + 1);
				n = tnode + 1;
				rdb();
				step0();
				pasos();
			}
		}
		catch(Exception e)
		{
			return;
		}
	}
	
	public void pasos()
	{
		for(;;)
		{
			if (step == 1) 
			{
				step1();
				if (v[tnode].dist < 0)
					termino();
				else
					step = 2;
			}
			else if(step == -1)
			{
				return;
			}
			else
			{
				step2();
				step = 1;
			}
		}
	}

	private void termino() 
	{
		int acumulado = 0;
		for(int i = 0; i < e.length; i++)
		{
			if(e[i] != null)
			{
				if(e[i].rndd_plus == snode)
				{
					acumulado += e[i].flow;
				}
			}
		}
		step = -1;
		System.out.println(acumulado + "");
	}
	
	public static void main(String [] args)
	{
		angry ag = new angry();
		ag.init();
	}
	

	class Comparador implements Comparator <Edge> 
	{
		public int compare(Edge arg0, Edge arg1) 
		{
			if(arg0.rndd_plus > arg1.rndd_plus)
			{
				return 1;
			}
			else if(arg0.rndd_plus < arg1.rndd_plus)
			{
				return -1;
			}
			else
			{
				if(arg0.rndd_minus > arg1.rndd_minus)
				{
					return 1;
				}
				else if(arg0.rndd_minus < arg1.rndd_minus)
				{
					return -1;
				}
				else
				{
					return 0;
				}
			}
		}

	}

	class Node 
	{
		int	delta_plus;	/* edge starts from this node */
		int	delta_minus;	/* edge terminates at this node */
		int	dist;		/* distance from the start node */
		int	prev;		/* previous node of the shortest path */
		int	p_edge;
		int	l;
		int	w;
		int	h;
		int	name;
	}

	class Edge 
	{
		int	rndd_plus;	/* initial vertex of this edge */
		int	rndd_minus;	/* terminal vertex of this edge */
		int	delta_plus;	/* edge starts from rndd_plus */
		int	delta_minus;	/* edge terminates at rndd_minus */
		int	capacity;	/* capacity */
		int	flow;		/* flow */
		int	st;
	}
}

\end{verbatim}

\section{LCA}

\begin{verbatim}

#include <iostream>
#include<vector>
#define abs(X) ((X) < 0 ? (-(X)) : (X))

using namespace std;

struct Query;

struct Nodo
{
    vector <Nodo*> adjacentes;
    vector <Query*> queries;
    int numero;
    long long distanciaCero;
    Nodo *parent;
    Nodo *ancestor;
    int rank;
    bool encontrado;

    void clear(int i)
    {
        numero = i;
        distanciaCero = 0;
        adjacentes.clear();
        queries.clear();
        encontrado = false;
    }
};

struct Query
{
    Nodo *a, *b;
    long long respuesta;
};

Nodo nodos[100001];
Query queries[100001];

void makeSet(Nodo *x)
{
     x->parent = x;
     x->rank   = 0;
}

Nodo* find(Nodo *x)
{
     if(x->parent == x)
        return x;
     else
     {
        x->parent = find(x->parent);
        return x->parent;
     }
}

int unir(Nodo *x, Nodo *y)
 {
     Nodo *xRoot = find(x);
     Nodo *yRoot = find(y);
     if(xRoot->rank > yRoot->rank)
         yRoot->parent = xRoot;
     else if(xRoot->rank < yRoot->rank)
         xRoot->parent = yRoot;
     else if(xRoot != yRoot)
     {
         yRoot->parent = xRoot;
         xRoot->rank = xRoot->rank + 1;
     }
 }


void tarjanOLCA(Nodo *u)
{
    makeSet(u);
    u->ancestor = u;
    for(int i = 0; i < u->adjacentes.size(); i++)
    {
        tarjanOLCA(u->adjacentes[i]);
        unir(u, u->adjacentes[i]);
        find(u)->ancestor = u;
    }
    u->encontrado = true;
    for(int i = 0; i < u->queries.size(); i++)
    {
        Query *actual = u->queries[i];
        Nodo *v;
        if(u == actual->a)
            v = actual->b;
        else
            v = actual->a;
        if(v->encontrado)
        {
            Nodo *ancestro = find(v)->ancestor;
            if(ancestro == v || ancestro == u)
                actual->respuesta = abs(v->distanciaCero - u->distanciaCero);
            else
                actual->respuesta = u->distanciaCero + v->distanciaCero - (2 * ancestro->distanciaCero);
        }
    }
}

int main()
{
    while(true)
    {
        int n;
        cin >> n;
        if(n == 0)
            break;
        nodos[0].clear(0);
        for(int i = 1; i < n; i++)
        {
            nodos[i].clear(i);
            int anterior, costo;
            cin >> anterior >> costo;
            nodos[anterior].adjacentes.push_back(&nodos[i]);
            nodos[i].distanciaCero = nodos[anterior].distanciaCero + costo;
        }
        int q;
        cin >> q;
        for(int i = 0; i < q; i++)
        {
            int s, t;
            cin >> s >> t;
            queries[i].a = &nodos[s];
            queries[i].b = &nodos[t];
            nodos[s].queries.push_back(&queries[i]);
            nodos[t].queries.push_back(&queries[i]);
        }
        tarjanOLCA(&nodos[0]);
        cout << queries[0].respuesta;
        for(int i = 1; i < q; i++)
        {
            cout << " " << queries[i].respuesta;
        }
        cout << endl;
    }
}

\end{verbatim}

\section{Prim}

\begin{verbatim}

import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Hashtable;

public class Prim
{
	static class PriorityQueue
	{
	     private int currentSize;
	     private PriorityQueueItem[] array;

	     public PriorityQueue(int capacidad)  
	     {
	         currentSize = 0;
	         array = new PriorityQueueItem[capacidad + 1];
	     }

	     public int insert(PriorityQueueItem x)  
	     {
	         if(currentSize + 1 == array.length)
	             doubleArray();
	         int hole = ++currentSize;
	         array[0] = x;
	         array[0].setPosition(0);
	         for(; x.compareTo(array[hole / 2]) < 0; hole /= 2)
	         {
	             array[hole] = array[hole / 2];
	             array[hole].setPosition(hole);
	         }
	         array[hole] = x;
	         array[hole].setPosition(hole);
	         return hole;
	     }

	     public void decreaseKey(PriorityQueueItem newVal)  
	     {
	         int hole = newVal.position();
	         array[0] = newVal;
	         array[0].setPosition(0);
	         for(; newVal.compareTo(array[hole / 2]) < 0; hole /= 2)
	         {
	             array[hole] = array[hole / 2];
	             array[hole].setPosition(hole);
	         }
	         array[hole] = newVal;
	         array[hole].setPosition(hole);
	     }

	     public PriorityQueueItem deleteMin()  
	     {
	         PriorityQueueItem minItem = array[1];
	         array[1] = array[currentSize--];
	         array[1].setPosition(1);
	         percolateDown(1);
	         return minItem;
	     }

	     public boolean isEmpty()
	     {
	         return currentSize == 0;
	     }

	     private void percolateDown(int hole)
	     {
	         int child;
	         PriorityQueueItem tmp = array[hole];
	         for(; hole * 2 <= currentSize; hole = child)
	         {
	             child = hole * 2;
	             if(child != currentSize && array[child + 1].compareTo(array[child]) < 0)
	                 child++;
	             if(array[child].compareTo(tmp) < 0)
	             {
	                 array[hole] = array[child];  
	                 array[hole].setPosition(hole);
	             }
	             else
	                 break;
	         }
	         array[hole] = tmp;
	         array[hole].setPosition(hole);
	     }

	     private void doubleArray()  
	     {
	         PriorityQueueItem[] newArray;
	         newArray = new PriorityQueueItem[array.length * 2];
	         for( int i = 0; i < array.length; i++ )
	             newArray[i] = array[i];
	         array = newArray;
	     }
	}
	
	static abstract class PriorityQueueItem
	{
	     int dist = Integer.MAX_VALUE;
	     private int position;

	     public int position()
	     {
	         return position;
	     }

	     public void setPosition(int newPosition)
	     {
	         position = newPosition;
	     }

	     public int compareTo(PriorityQueueItem o)
	     {
	         return new Integer(dist).compareTo(o.dist);
	     }
	}
	
	static int[][] pesos = new int[400][400];
	
	static class Ciudad extends PriorityQueueItem
	{
		String nombre;
		int posicion;
		Ciudad parent = null;
		boolean is_in_q = true;
		ArrayList <Ciudad> adjacentes = new ArrayList <Ciudad> ();
		
		public Ciudad(String n, int pos) {
			nombre = n;
			posicion = pos;
			dist = Integer.MAX_VALUE;
		}
	}
	
	static class Vertice
	{
		Ciudad a, b;
		int costo;
		
		public Vertice(Ciudad a, Ciudad b, int costo) {
			super();
			this.a = a;
			this.b = b;
			this.costo = costo;
		}
		
	}
	
	public static void main(String [] args)
	{
		Hashtable <String, Ciudad> hash = new Hashtable <String, Ciudad> ();
		Scanner sc = new Scanner();
		while(true)
		{
			int s = sc.nextInt();
			int c = sc.nextInt();
			if(s == 0 && c == 0)
				return;
			for(int i = 0; i < s; i++)
				for(int j = 0; j < s; j++)
				{
					pesos[i][j] = Integer.MAX_VALUE;
				}
			ArrayList <Ciudad> ciudades = new ArrayList <Ciudad> (s);
			for(int i = 0; i < s; i++)
			{
				String actual = sc.next();
				Ciudad nueva = new Ciudad(actual, i);
				hash.put(actual, nueva);
				ciudades.add(nueva);
			}
			for(int i = 0; i < c; i++)
			{
				String c1 = sc.next();
				String c2 = sc.next();
				int costo = sc.nextInt();
				Ciudad ci1 = hash.get(c1);
				Ciudad ci2 = hash.get(c2);
				int pos1 = ci1.posicion;
				int pos2 = ci2.posicion;
				ci1.adjacentes.add(ci2);
				ci2.adjacentes.add(ci1);
				pesos[pos1][pos2] = costo;
				pesos[pos2][pos1] = costo;
			}
			String ini = sc.next();
			Ciudad inicial = hash.get(ini);
			inicial.dist = 0;
			PriorityQueue q = new PriorityQueue(s);
			for(Ciudad ci : ciudades)
				q.insert(ci);
			while(!q.isEmpty())
			{
				Ciudad latest = (Ciudad) q.deleteMin();
				latest.is_in_q = false;
				for(Ciudad adj : latest.adjacentes)
				{
					if(adj.is_in_q && pesos[latest.posicion][adj.posicion] < adj.dist)
					{
						adj.parent = latest;
						adj.dist = pesos[latest.posicion][adj.posicion];
						q.decreaseKey(adj);
					}				
				}
			}
			int valorTotal = 0;
			boolean termino = false;
			for(Ciudad ci : ciudades)
			{
				if(ci.dist == Integer.MAX_VALUE)
				{
					System.out.println("Impossible");
					termino = true;
					break;
				}
				valorTotal += ci.dist;
			}
			if(!termino)
				System.out.println(valorTotal);
		}
	}
}

\end{verbatim}

\section{SCC}

\begin{verbatim}

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Set;
	

// Strongly connected components

public class SCC
{
	static class Node implements Comparable<Node> {
		   
		   final int name;
		   String nombre;
		   boolean visited = false;   // used for Kosaraju's algorithm and Edmonds's algorithm
		   int lowlink = -1;          // used for Tarjan's algorithm
		   int index = -1;            // used for Tarjan's algorithm
		   
		   public Node(final int argName, String n) {
		       name = argName;
		       nombre = n;
		   }
		   
		   public int compareTo(final Node argNode) {
		       return argNode == this ? 0 : -1;
		   }
		}
	
	static class Edge implements Comparable<Edge> {
		   
		   final Node from, to;
		   final int weight;
		   
		   public Edge(final Node argFrom, final Node argTo, final int argWeight){
		       from = argFrom;
		       to = argTo;
		       weight = argWeight;
		   }
		   
		   public int compareTo(final Edge argEdge){
		       return weight - argEdge.weight;
		   }
		}

	static class AdjacencyList {

	   private Map<Node, ArrayList<Edge>> adjacencies = new HashMap<Node, ArrayList<Edge>>();

	   public void addEdge(Node source, Node target, int weight){
	       ArrayList<Edge> list;
	       if(!adjacencies.containsKey(source)){
	           list = new ArrayList<Edge>();
	           adjacencies.put(source, list);
	       }else{
	           list = adjacencies.get(source);
	       }
	       list.add(new Edge(source, target, weight));
	   }

	   public ArrayList<Edge> getAdjacent(Node source){
	       return adjacencies.get(source) == null ? new ArrayList<Edge>() : adjacencies.get(source);
	   }

	   public void reverseEdge(Edge e){
	       adjacencies.get(e.from).remove(e);
	       addEdge(e.to, e.from, e.weight);
	   }

	   public void reverseGraph(){
	       adjacencies = getReversedList().adjacencies;
	   }

	   public AdjacencyList getReversedList(){
	       AdjacencyList newlist = new AdjacencyList();
	       for(ArrayList<Edge> edges : adjacencies.values()){
	           for(Edge e : edges){
	               newlist.addEdge(e.to, e.from, e.weight);
	           }
	       }
	       return newlist;
	   }

	   public Set<Node> getSourceNodeSet(){
	       return adjacencies.keySet();
	   }

	   public Collection<Edge> getAllEdges(){
	       ArrayList<Edge> edges = new ArrayList<Edge>();
	       for(List<Edge> e : adjacencies.values()){
	           edges.addAll(e);
	       }
	       return edges;
	   }
	}
	


	static int index = 0;
	static ArrayList<Node> stack = new ArrayList<Node>();
	static ArrayList<ArrayList<Node>> SCC = new ArrayList<ArrayList<Node>>();
	public static  ArrayList<ArrayList<Node>> tarjan(Node v, AdjacencyList list){

		v.index = index;
		v.lowlink = index;
		index++;
		stack.add(0, v);
		for(Edge e : list.getAdjacent(v)){
			Node n = e.to;
			if(n.index == -1){
				tarjan(n, list);
				v.lowlink = Math.min(v.lowlink, n.lowlink);
			}else if(stack.contains(n)){
				v.lowlink = Math.min(v.lowlink, n.index);
			}
		}
		if(v.lowlink == v.index){
			Node n;
			ArrayList<Node> component = new ArrayList<Node>();
			do{
				n = stack.remove(0);
				component.add(n);
			}while(n != v);
			SCC.add(component);
		}
		return SCC;
	}
	
	public static void main(String[] args) throws FileNotFoundException
	{	
		Scanner sc = new Scanner();
		while(true)
		{
			index = 0;
			stack = new ArrayList<Node>();
			SCC = new ArrayList<ArrayList<Node>>();
			int p = sc.nextInt();
			int t = sc.nextInt();
			if(p == t && p == 0)
				return;
			Node[] nodos = new Node[p];
			Hashtable <String, Node> hash = new Hashtable <String, Node> (p);
			for(int i = 0; i < p; i++)
			{
				nodos[i] = new Node(i, sc.nextLn());
				hash.put(nodos[i].nombre, nodos[i]);
			}
			AdjacencyList al = new AdjacencyList();
			for(int i = 0; i < t; i++)
			{
				al.addEdge(hash.get(sc.nextLn()), hash.get(sc.nextLn()), 1);
			}
			for(int i = 0; i < p; i++)
			{
				if(nodos[i].index == -1)
					tarjan(nodos[i], al);
			}
			System.out.println(SCC.size());
		}
		
	}
}

\end{verbatim}

\end{document}